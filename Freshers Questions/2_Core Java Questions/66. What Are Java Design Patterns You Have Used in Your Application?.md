# 66. What Are Java Design Patterns You Have Used in Your Application?

## Common Design Patterns in Java

### Singleton Pattern:
- **Purpose:** Ensures a class has only one instance and provides a global point of access to it.
- **Use Case:** Managing a shared resource like database connections or configuration objects.
- **Example:**
  ```java
  public class Singleton {
      private static Singleton instance;
      
      private Singleton() {}  // private constructor
      
      public static Singleton getInstance() {
          if (instance == null) {
              instance = new Singleton();
          }
          return instance;
      }
  }
  ```

## Common Design Patterns in Java

### Singleton Pattern:
- **Purpose:** Ensures a class has only one instance and provides a global point of access to it.
- **Use Case:** Managing a shared resource like database connections or configuration objects.
- **Example:**
  ```java
  public class Singleton {
      private static Singleton instance;
      
      private Singleton() {}  // private constructor
      
      public static Singleton getInstance() {
          if (instance == null) {
              instance = new Singleton();
          }
          return instance;
      }
  }
    ```
## Common Design Patterns in Java

### Observer Pattern:
- **Definition:** Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.
- **Use Case:** Used in scenarios like GUI event listeners or notifying subscribers in a messaging system.
- **Example:** `java.util.Observer` and `java.util.Observable`.

### Decorator Pattern:
- **Definition:** Allows behavior to be added to individual objects, dynamically, without affecting the behavior of other objects from the same class.
- **Use Case:** Used when you need to add functionalities to objects without modifying the original class.
- **Example:** `java.io.BufferedReader` and `java.io.FileReader`.

### Strategy Pattern:
- **Definition:** Defines a family of algorithms, encapsulates each one, and makes them interchangeable. The strategy pattern allows the algorithm to vary independently from the clients that use it.
- **Use Case:** Used when you need to select an algorithm at runtime.
- **Example:** `java.util.Comparator`.
